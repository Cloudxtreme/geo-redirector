map $arg_video_uri $cr_classic {
    default 1;
    ""      0;
}
map $cr_classic $balance_factor {
    0       $uri;
    1       $arg_video_uri;
}

lua_shared_dict disabled_nodes 1m;
limit_req_zone $balance_factor zone=rr:300m rate=25r/m;
init_by_lua '
    yaml = require "lyaml"
    local file = "/etc/nginx/redro.yaml"
    local f, err = io.open(file, "r")
    if not f then return nil, err end
    cfg = yaml.load(f:read("*all"))
    cluster_total = {}
    cluster_keys = {}
    checklist = {}
    nodenames = {}
    for cluster, nodes in pairs(cfg["clusters"]) do
        cluster_total[cluster] = 0
        cluster_keys[cluster] = 0
        for address, attribs in pairs(nodes) do
            cluster_total[cluster] = cluster_total[cluster] + attribs["weight"]
            cluster_keys[cluster] = cluster_keys[cluster] + 1
            table.insert(checklist, { "/query_one", { vars = {qhost = address, quri = cfg["check_uri"]}}})
            table.insert(nodenames, address)
        end
        ngx.log(ngx.INFO, ("cluster %s: total weight=%s"):format( cluster, cluster_total[cluster] ))
    end

    function md5_last48bits(data)
        local binhash = ngx.md5_bin(data)
        local hash = 0
        for i=11, 16 do hash = 256 * hash + binhash:byte(i) end
        return hash
    end

    function node_vector(seed, nodes)
        local result = {}
        local used = {}
        local len = 0
        local tw = 0
        for address, attribs in pairs(nodes) do
            tw = tw + attribs["weight"]
            len = len + 1
        end

        local cs = seed
        for i=1, len do
            local rem = math.fmod(cs, tw)
            cs = math.floor(cs / tw)
            for address, attribs in pairs(nodes) do
                if used[address] == nil then
                    if rem < attribs["weight"] then
                        table.insert(result, address)
                        used[address] = true
                        break
                    end
                    rem = rem - attribs["weight"]
                end
            end

            tw = tw - nodes[result[#result]]["weight"]
        end

        return result
    end

    function balance_req(seed, nodes, disabled_nodes)
        local nv = node_vector(seed, nodes)
        for k, v in pairs(nv) do
            if disabled_nodes:get(v) == null then
                if ngx.var.cr_classic == "0" then
                    ngx.status = ngx.HTTP_MOVED_TEMPORARILY
                    ngx.header["Location"] = ("%s://%s%s"):format(ngx.var.scheme, v, ngx.var.request_uri)
                else
                    ngx.status = ngx.HTTP_OK
                    ngx.print(v)
                end
                ngx.eof()
            end
        end
    end

    function query_http()
        local resps = { ngx.location.capture_multi(checklist) }
        local disabled = ngx.shared.disabled_nodes
        disabled:set("sentinel_run_at", ngx.time())
        for i, resp in ipairs(resps) do
            if resp.status >= 500 and resp.status <= 599 then
                disabled:add(nodenames[i],1)
                ngx.log(ngx.WARN, "node is down: ", nodenames[i], " response=", tostring(resp.status))
            else
                disabled:delete(nodenames[i])
                ngx.log(ngx.DEBUG, "node is alive: ", nodenames[i])
            end
        end
    end
';

geo $dest_group {
    default             main;
    100.64.0.0/10       ufa;
    136.169.128.0/17    ufa;
    145.255.0.0/19      ufa;
    46.191.128.0/17     ufa;
    77.79.128.0/18      ufa;
    79.140.16.0/20      ufa;
    81.30.176.0/20      ufa;
    81.30.192.0/19      ufa;
    84.39.240.0/20      ufa;
    89.189.128.0/18     ufa;
    92.50.128.0/17      ufa;
    94.41.0.0/16        ufa;
    95.105.0.0/17       ufa;
}

server {
    listen 80;
    listen 8100;
    listen 8123;
    listen 443 ssl;
    ssl_certificate /etc/nginx/ssl/tvigle_ru_2016_02_26.crt;
    ssl_certificate_key /etc/nginx/ssl/pk2014.key;
    lua_use_default_type off;

    include /etc/nginx/conf.d/antiseo.conf;
    server_name  distribution.tvigle.ru video.tvigle.ru;

    access_log  /var/log/nginx/distribution.access.log custom buffer=128k; 
    error_log  /var/log/nginx/distribution.error.log; 
    log_not_found off;
    
    location = /favicon.ico { return 404; }    

    location = /crossdomain.xml {
        root /var/www/tvigo.ru;
        access_log off;
    }

    location / {
        error_page 418 = @wrr_balance;
        limit_req zone=rr nodelay;
        limit_req_status 418;
        content_by_lua '
            local disabled = ngx.shared.disabled_nodes
            balance_req(md5_last48bits(ngx.var.balance_factor), cfg["clusters"][ngx.var.dest_group], disabled)

            local last_run = disabled:get("sentinel_run_at")
            if last_run == nil or (ngx.time() - last_run) > cfg["check_interval"] then
                query_http()
            end
        ';
    }
    location @wrr_balance {
        content_by_lua '
            local disabled = ngx.shared.disabled_nodes
            balance_req(math.random(256^6-1), cfg["clusters"][ngx.var.dest_group], disabled)

            local last_run = disabled:get("sentinel_run_at")
            if last_run == nil or (ngx.time() - last_run) > cfg["check_interval"] then
                query_http()
            end
        ';
    }

    location = /force_check {
        default_type text/plain;
        set $qhost "";
        set $quri "";
        content_by_lua '
            query_http()
            for _, v in ipairs(ngx.shared.disabled_nodes:get_keys()) do
                ngx.say( ("Disabled: %s"):format(v) )
            end
        ';
    }

    location = /get_blocked {
        default_type text/plain;
        set $qhost "";
        set $quri "";
        content_by_lua '
            for _, v in ipairs(ngx.shared.disabled_nodes:get_keys()) do
                ngx.say( ("Disabled: %s"):format(v) )
            end
        ';
    }

	location = /query_one {
            proxy_ignore_client_abort on;
            proxy_connect_timeout   1000ms;
            proxy_read_timeout      1000ms;    
            rewrite ^ $quri break;
            proxy_pass http://$qhost;
        }
}
